## 浏览器性能优化措施

### 采用RAIL来测量网站的性能
- R:Response，在100ms内响应用户的输入
- A:Animation，生成一帧动画需要限制在16ms内，浏览器需要6ms左右，留给js的时间仅仅有10ms
- I:IDLE 保持主线程处于空闲状态，交给主线程执行js的时间要限制在50ms以内
- L:Load页面需要在1s内呈现（框架或者大概），其余的资源可以在后台加载

### Loading Performance

#### 测试页面的性能
- chrome devtools audits面板中的lightHouse工具
- PageSpeed Insights（https://developers.google.com/speed/pagespeed/insights/）
- WebPageTest（https://www.webpagetest.org/）
- Pingdom（https://tools.pingdom.com/）

#### Text Content内容
- 利用webpack、gulp等工具对html、js、css文件进行压缩
- 采用Gzip来压缩文件（对图片等已经压缩过的内容效果很小）
- 如何只采用一些库的几个函数，自己手写，不要引用

#### Graphical Content
- 首先要问一下你自己这些图片是不是需要的
- 选择合适的图片类型，像png的图像视觉效果比jpg要好，尺寸也大一些，但是有时候在网页上，png、jpg类型的图片根本看不出区别
- 有些图片存在一些metadata比方说想作者，拍摄设备等，可以通过（http://www.verexif.com/en/）这样的网站去除照片的metadata
- 裁减图片不必要的地方可以减少图片的尺寸
- 通过一些工具（paint.net）能减少图片的清晰度和尺寸，但是在web page上并不会有明显的区别，需要逐步进行测试
- 一些网站（https://tinypng.com/）能够进一步压缩图片，同时还不影响图片的清晰度

#### HTTP requests
- 将多个分散的css file、js file合并为一个文件，能有效减少http请求的次数，但是要注意*同名css属性、js函数名字覆盖的问题*（HTTP2不要这样）
- 将多个小的图标（icons）合成为一张雪碧图，通过css background position属性展示不同的icone，能有效地节省带宽（HTTP2不要这样）
- js文件的下载会阻塞html页面的渲染，可以将js文件链接存放到body标签的最末
- 直接将js code写在需要操作dom附近的< script >标签内，这样可以避免一次http请求js文件


cache-control控制浏览器缓存（Expires Caching是该字段的一个fallback）
- no-cache：可以缓存，但是每次去服务器验证缓存的数据是否可用
- no-store:不可以缓存，每次都要去服务器请求新的数据
- must-revalidate：如果缓存不过期就继续使用，如果缓存过期之后还想使用该缓存就必须向服务器进行验证
- public：能被浏览器缓存，也能被中间服务器缓存
- private：只能被浏览器缓存，中间设备不能缓存改数据
- max-age：可以缓存的时间，最高可以缓存一年
- （no-cache和no-store、must-revalidate互斥；private和public互斥）


#### 在真是环境下如何测量页面的性能
浏览器在performance命名环境下面提供了一些api来供用户测量页面的性能
```js
// 获取html文件的性能指标
performance.getEntriesByType('navigation');

// 获取文件的性能指标（js、css、img文件等、xhr接口请求）
performance.getEntriesByType('resource');

// 获取特定接口的性能指标
performance.getEntriesByName('https://somesite.com/images/hero-image.jpg');
```

一些用于测量页面性能的指标：
```js
var pageNav = performance.getEntriesByType('navigation')[0];
// 查询DNS的时间
var dnsTime = pageNav.domainLookupEnd = pageNav.domainLookupStart;


// 如果是http请求，请求的negotiation time（TCP建立时间）
var connectionTime = pageNav.connectedEnd - pageNav.connectedStart; // 对于https而言是0
// 如果是http请求，请求的negotiation time（TCP建立时间、TLS协商密钥等时间）
var connectionTime = pageNav.connectedEnd - pageNav.secureConnectedStart; // 对于http而言是0

// 包括检查磁盘cache的时间，应该包括了DNS查询、negotiation Time、获取完整的文档时间
var fetechTime = pageNav.responseEnd - pageNav.fetchStart;

// 网络请求时间（DNS、negotiation Time）
var totalTime = pageNav.responseEnd - pageNav.requestStart;
// download时间
var downloadTime = pageNav.responseEnd - pageNav.responseStart;
// TTFB时间
var ttfb = pageNav.responseStart - pageNav.requestStart;

// HTTP header size 
// transferSize表示文件全部的大小
var headerSize = pageNav.transferSize - pageNav.encodedBodySize;
// 文件的压缩率
var compressRatio = pageNav.decodedBodySize / pageNav.encodedBodySize;
```

使用Timing API时候要注意的一些信息
- 在跨域访问资源的时候，需要设置Timing-Allow-Origin header来允许其访问Resource Timing API提供的相关信息
- getEntriesByType等API在浏览器中并不总是实现了的
- 可以采用PerformanceObserver来监控页面Performance性能

如何保存Performance相关的数据？
- navigator.sendBeacon API提供一个非阻塞的POST API在unload事件发生的时候（不阻塞页面的跳转）


### js是如何影响性能的

#### 传输性能（network）
用户的网络环境可能不是很好，所以需要优化js传输的大小来提高性能

- 传输用户需要的js
  - 用code-splitting来分割代码
  - 对于非关键的js的文件资源，可以使用懒加载
- minification
  - 用Uglify JS来youhua ES5的代码
  - 用babel-minify或者uglify-es来优化ES2015+的代码
- 压缩
  - 用gzip的方式来压缩js文件
  - Brotli~q11来压缩文件，这种压缩方式比gzip要好上一些
- 移除不需要的代码
  - 用babel-preset-env来避免对一些功能的pollify（这些功能很可能大多数浏览器已经支持了）
  - tree-shaking、Closure Compiler’s advanced optimizations、还有一些库的插件进行tree-shaking
- 缓存js代码
  - HTTP caching
  - Service Worker caching（v8）

#### 运行性能（cpu）
- parse/compile
  - 代码写好一点
  - 首屏加载的js文件尽可能的小
- execution
  - 避免一个js任务的执行超过了50ms，会给用户交互粘滞感
  - 如果任务运行时间过长，可以采用(using requestAnimationFrame() or requestIdleCallback())来减缓

### img和video属性的lazy loading

#### img
1、img标签只要设置了src属性，浏览器会自动下载图片，所以可以为img元素设置一个data-src属性来存储图片的真实名称和路径，
src属性先设置了一个placeholder图片。之后结合IntersectionObserve API和js，当img元素滚动到viewport的时候，设置
img标签src的真实属性，loading图片
```html
<img class="lazy" src="placeholder-image.jpg" data-src="image-to-lazy-load-1x.jpg" data-srcset="image-to-lazy-load-2x.jpg 2x, image-to-lazy-load-1x.jpg 1x" alt="I'm an image!">
<script>
document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll("img.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target;
          lazyImage.src = lazyImage.dataset.src;
          lazyImage.srcset = lazyImage.dataset.srcset;
          lazyImage.classList.remove("lazy");
          lazyImageObserver.unobserve(lazyImage);
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage);
    });
  } else {
    // Possibly fall back to a more compatible method here
  }
</script>
```
2、在css中设置元素的属性，css设置元素的background-imge属性有些不同，img属性只要设置了src，浏览器都会请求资源。
一条css规则设置了background-imga属性时，当这条css规则没有被应用的时候，不下载资源，当这条css规则被应用去构建
dom结构的时候，浏览器会请求相关的资源
```css
.lazy-background {
  background-image: url("hero-placeholder.jpg"); /* Placeholder image */
}

.lazy-background.visible {
  background-image: url("hero.jpg"); /* The final image */
}
```
当用户滚动到相关的区域的时，通过IntersectionObserve API来将图片tag元素的class从lazy-background改变为lazy-backgroudn.visible
就能够实现图片的懒加载。


#### vedio
1、对于video标签的lazy loading只需要设置其属性preload = none即可实现视频的懒加载，只有当用户播放视频的时候，视频方加载。
poster属性类似于img标签的placeholder属性，能够实现对video标签的占位。

2、video也可以播放git图片，通常而言video的压缩率是优于gif图片的，只有下面的一些不同
- gif loaded之后是自动播放的
- gif 可能会无限循环播放
- gif 没有video的播放条

为了模拟gif的表现形式，可以对video属性设置如下的属性
```html
<video autoplay muted loop playsinline>
  <source src="one-does-not-simply.webm" type="video/webm">
  <source src="one-does-not-simply.mp4" type="video/mp4">
</video>
```


#### appendix（IntersectionObserve）


### Rendering Performance


### 网页运行时Performance overview
统共分为Evaluate script、recalculate Style、Layout（reflow）、Paint and composite

Evaluate Script
- 页面交互的handler（js）计算时间长【尽可能让浏览器处理touch、scroll等事件】
- js计算的时间过长【用web Works、requestAnimationFrame】
- 频繁的垃圾回收【看看代码是不是写傻逼了】

Recaculate Style：
- 改变元素几何属性（width、height、position），浏览器要重新生成layout布局
- 非常复杂嵌套的选择器【浏览器花费更长的时间】

Layout：
- 强制同步布局【设置元素的属性之后，再访问元素属性，强制浏览器发生一次布局】
- 同步布局抖动【在循环中不断地重复强制同步布局】

Paint and composite（这个性能问题应该不是很大）