### ionic APP

#### 布局
app是一个典型的header-body-footer的结构，其中
- header高度固定
- body是内容填充区域，内容多的时候可以滚动展示
- footer固定高度，永远吸底

当时没有给app抽象出几个典型的抽象布局组件，每个主路由页都重复描述布局，且布局用的是vh、vw绝对布局，无法避免刘海屏的问题

现在看来可以改进的地方
- 抽象几个典型的布局组件
- 布局组件的height可以通过html、body 100%的方式来布局
- 可以借助env()函数和safe-area-inset-top等内置的变量还保障内容显示在特定区域
- body内容区域的刷新只能通过header中tab的切换来达成，其实可以做一些下拉刷新
- 切换tab的时候，由于后端接口对tab的建模是query参数，所以存在竟态问题，现在有更成熟的解决方案
- 切换tab拉取接口的时候，需要再body内容区域做loading看起来更好，这些都可以集中在布局组件内


#### 状态流转

这个项目起的很着急，很多地方都是别人搭起来的，谈不上设计，状态管理虽然引入了全局store，但是存在很大的问题。状态没有区分，要么一股脑倒入全局store，要么一股脑通过vue router的参数来传递


现在看起来可以改进的地方
- 一些重复刷新可进入，可分享的页面，最好通过url参数的形式的来做
- 将状态划分为全局store状态和局部页面状态至关重要，这个可能要依赖经验和项目的定位
- 整个app的全局store状态流转，其实就是状态机，所以可以引入有限状态自动机的方式来描述整个app的页面
- 状态机的core可以先简单一些，但是保留扩展性，后续可以慢慢加入状态迭代


##### 状态设计延伸

现在前端框架Vue、angular、react的理念都是`数据驱动`，数据是页面的描述，页面展示为`Data + css + 本地少许状态`，UI是朝生夕死的，变动是比较大的，如何
设计团队的前端业务架构是非常值得思考的问题


业务逻辑是不容易发生变化的，`与UI无关`。Modal层，应该是一组纯粹的class类或者函数，内部只引用一些lodash之类的工具包，是业务规则的描述。可以对接Vue，也可以对接
React、Angular，甚至可以运行在node环境下


这种情况下，Vue和React作为很薄的一层视图层，只做下面的事情
- 获取Modal层数据且跟DOM进行关联
- 一些本地local状态如loading等
- （可选），可以通过Vuex、Mobx来维护Modal层的缓存


#### 权限问题
权限这块做的也比较零散，不成系统，后续再权限方面并没有投入，这块暂时没有好的想法


#### 性能问题
ionic app的性能是非常有问题的，但是问题的大头主要在后端，后端的接口响应时长（首屏）30s+，
从前端的性能来看，问题其实比较小，整个app打包之后的bundle不是特别大（主要涉及到echarts图标，打包后包大一些）
现在来看可以通过devtools提供的很多性能相关的工具（performance、lighthouse）来做


### 埋点SDK
埋点SDK整体而言做的还算可以，主要的工作就是兼容之前的接口和版本，然后依据个性化需求迭代一下（只有业务上的break change）
- 基于es6的语法来做，整体比较清晰
- 对于一些需要保留自动化埋点的业务线，依赖webpack打包注入参数，拆分单双版本
- 可视化页面，为了保障库的小，基于xhr封装了http请求库；递归生成可视化JSON片段


后续面试遇到很多人询问web端模块pv、click等如何统计，一个基本的思路是可以预先商定id或者特殊标识（预先将这些信息传 SDK 可以，比方说id、class ），依赖dom API提供 mutationObserver接口， 观测DOM 改动。同时sdk填充基础的信息，进行发送。


### form表单相关

#### 如何使用antd提供form表单校验
像antd、element UI等组件库都提供了form表单，提供校验和错误提示等较为通用的逻辑。每一个field都被类似于<form-item>之类的抽象组件包裹，
这个抽象组件作用：
- 给每一个field添加对应的label，像checkbox之类的组件还可以提供类似于原生选中label即选中组件效果
- 包裹核心组件，为组件提供空间，在校验的时候能够比较好的现实错误信息
- 重置表单信息等

对于一些复杂一些组件，比方说省市区联动组件作为一个form-item（视觉上），在开发的过程中，对这类复杂组件，每一个field都包裹一个form-item组件
视觉上的效果可以通过包裹div，css `flex grid`布局来完成
